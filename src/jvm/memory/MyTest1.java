package jvm.memory;

import java.util.ArrayList;
import java.util.List;

/**
 * 虚拟机栈：里面的数据叫做（Stack Frame） 栈帧。线程私有的，随着线程的创建和消亡而存在。局部变量表存放包括原生类型和引用类型（指向堆中的对象）。
 * stackoverflow：堆栈溢出错误。极少出现outofmemory。
 *
 * 程序计数器（Program Counter），线程私有的。记录程序正在执行的字节码，记录着位置，方便线程挂起后继续执行。记录线程执行的行号。
 *
 * 本地方法（native method）栈：主要用于处理本地方法，是与native方法有关的，主要的结构和虚拟机栈类似的。hotspot虚拟机把本地方法栈和虚拟机栈合二为一了。
 *
 * 堆（Heap）：JVM管理的最大一块内存空间。堆内存上的的对象被所有线程共享。与堆相关的一个重要概念是垃圾收集器。现代几乎所有的垃圾收集器都是采用
 * 分代收集算法。所以堆空间也基于这一点进行了相应的划分：新生代和老年代。Eden空间，From Survivor空间与To Survivor空间。
 *
 * 方法区（Method Area）：存储元信息（类对象，常量等）。永久代（Permanent Generation），从JDK1.8开始，已经彻底废弃了永久代，使用元空间（meta space）
 *
 * 运行时常量池：方法区的一部分内容。
 *
 * 直接内存：Direct memory，不是由Java虚拟机直接管理的，与Java NIO密切相关。JVM通过堆上的DirectByteBuffer来操作直接内存。DirectByteBuffer位于
 * Java堆上的。
 *
 * Java堆空间可以是连续的，也可以是非连续的。
 *
 * 关于Java对象创建的过程：
 * new关键字创建对象的3个步骤：
 * 1。在堆内存中创建出对象的实例。
 * 2。为对象的实例成员变量赋初值。
 * 3。将对象的引用返回。
 *
 * 指针碰撞（前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间），当未被使用的空间放了一个对象以后，指针就指向了新的未被使用的空间。
 *
 * 实际的堆内存的空间使用的和未被使用的空间是交织在一起的。
 *
 * 空间列表（前提是堆内存中间中已被使用和未被使用的空间是交织在一起的。这时，
 * 虚拟机就需要通过一个列表来记录哪些空间是可以使用的，哪些空间是已被使用的，接下来找出
 * 可以容纳下新创建对象的且未被使用的空间，在此空间存放该对象，同时还要修改列表上的记录）
 *
 * 对象在内存中的布局：
 * 1。对象头
 * 2。实例数据（即我们在一个类中所声明的各项信息）
 * 3。对齐填充（可选）：起到一些占位符的作用。
 *
 * 引用访问对象的方式：
 * 1。使用句柄的方式；
 * 2。使用直接指针的方式
 */

/**
 *
 */

public class MyTest1 {
    public static void main(String[] args) {
        List<MyTest1> list = new ArrayList<>();
        for (;;) {
            list.add(new MyTest1());
            System.gc();
        }
    }
}
