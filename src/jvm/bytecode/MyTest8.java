package jvm.bytecode;

/**
 * 现代JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来。
 *
 * 所谓解释执行，就是通过解释器来读取字节码，遇到相应的指令就去执行该指令。
 * 所谓编译执行(和通常所说的编译不一样)，就是通过即时编译器（Just In Time, JIT）将字节码转换为本地机器码来执行；现代JVM会根据代码热点来生成
 * 相应的本地机器码。
 *
 * 注意：编译执行会将热点代码转换为本地机器码，这样会加快执行速度，但是机器码不能跨平台，可移植性不高。（语言描述估对）
 *
 * 基于栈的指令集与基于寄存器的指令集之间的关系：
 *
 * 1。JVM执行指令时所采取的方式是基于栈的指令集；
 * 2。基于栈的指令集主要的操作有入栈与出栈两种；
 * 3。基于栈的指令集的优势在于它可以在不同平台之间移植，而基于寄存器的指令集是与硬件架构紧密关联的，无法做到可移植。
 * 4。基于栈的指令集的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多；基于栈的指令集是在内存中完成操作的，
 *    而基于寄存器的指令集是直接由CPU来执行的，它是在高速缓冲区中进行执行的，速度要快很多。虽然虚拟机可以采用一些优化手段，
 *    但总体来说，基于栈的指令集的执行速度要慢一些。
 *
 *
 * 2 - 1：基于栈的指令集的操作
 *
 * 1.iconst_1:将减数1压入栈顶
 * 2.iconst_2：将被减数2压入栈顶
 * 3.isub：将栈顶以及栈顶下面的元素弹出来，弹出来之后执行2-1操作，还会将结果1压回栈顶。
 * 4.istore_0：将栈顶元素弹出来，放到局部变量表第0个位置上



iload_n:将局部变量表中索引为n处的元素推送到操作数栈中。

iadd：将栈顶的元素和栈顶下面的元素弹出来，执行相加操作，再将结果压入到操作数栈中。
isub:将栈顶的元素和栈顶下面的元素弹出来，执行相减操作，再将结果压入到操作数栈中。
ireturn：返回

 */

public class MyTest8 {

    public int myCalculate() {
        int a = 1;
        int b = 2;
        int c = 3;
        int d = 4;

        int result = (a + b - c) * d;

        return result;
    }
}
